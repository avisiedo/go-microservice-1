# go-microservice-1

This repository is a POC of template for boostraping a new
microservice based on golang. The features are:

- Design first approach: You boostrap your openapi with
  [apicurio][apicurio_site], and generate the code boilerplate for it.
- Provide local infrastructure.
- Automation to make developer life easier.

## Getting started

**Pre-requisites**:

- golang 1.20 (not `gcc-go`)
- docker or podman (>4.0.0)
- docker-compose or podman-compose
- python3
- openshift client [Installing OpenShift Client](https://docs.openshift.com/container-platform/4.12/cli_reference/openshift_cli/getting-started-cli.html#installing-openshift-cli).

Packages for fedora 37:

```sh
$ sudo dnf upgrade
$ sudo dnf install git golang podman podman-compose
$ sudo dnf remove gcc-go
```

(Optional) Installing VSCode by repository on fedora 37:

```sh
$ sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
$ cat <<EOF | sudo tee /etc/yum.repos.d/vscode.repo
[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc
EOF
$ sudo dnf check-update
$ sudo dnf install code
```

(Optional) Recomended extensions for vscode:

- Go (highly recommended)
- REST Client

Once tasks:

- Install used tools: `make install-tools`
- Create your `configs/config.yaml` file: `cp -vf configs/config.example.yaml configs/config.yaml`
- Create your `secrets/private.mk` file: `cp -vf scripts/mk/private.example.mk secrets/private.mk`
- Follow the instructions in `secrets/private.mk` to set up Quay repository
  and Red Hat Repository access.

> Directory `secrets/` is set to be ignored by git and docker.

----

- Build by: `make build`
- Launch tests by: `make test`
- Lint code by: `make lint`
- Start local infrastructure by: `make compose-up`
- Run by: `make run`
- Stop local infrastructure by: `make compose-down`
- Clean local infrastructure by: `make compose-clean`
- Print out useful rules by: `make help`

## Project layout

```raw
internal/   Define the internal application components
├── api
│   ├── private: The code generated for the private api.
│   └── public: The code generated for the public api (types, http
│               framework server specific, spec)
├── config: Hold the configuration structure and functions to read it.
├── domain
│   └── model: Define the business model of the application.
├── handler: Hold application and handler interfaces.
TODO Move to interface/presenter/repository
│   └── impl: Implementation for the application interface.''
TODO Move to usecases/presenter/repository
├── infrastructure: specific code coupled to the http framework.
│   ├── middleware: all the middleware components comes here.
│   ├── router: wire the route of the service composing the different
│   │           api groups, and adding the middlewares.
│   └── service: define the Service interface
│       └── impl: Implement a Service for the application and different
|                 listeners (api, metrics, kafka consumer)
├── interface: Define the interfaces for `interactor`,
│              `repository` and `presenter` components.
├── test: All the helpers for tests are here
│   └── mock: Store all the generated mocks for the interfaces,
│             keeping the same directory structure
└── usecase: specific implementation for the `interface` directory
             for interactor, presenter and repository components.

cmd/      Define the binaries generated

api/      Define the public and private openapi specification

deployments/   Hold descriptors to deploy local
               infrastructure with {podman,docker}-compose.

scripts/  Store useful scripts for the repository
├── db
│   └── migrations:  sql scripts for the migrations.
├── http:  Hold .http files to quickly check the API
└── mk:  Hold all the makefile scripts
```

See: https://github.com/golang-standards/project-layout

## Architecture and Design docs

See: [Architecture and design](docs/ARCHITECTURE.md).

## Design API

You can design your API importing the `public.openapi.yaml` file
at the local [apicurio][apicurio_site] instance (start it by
`make apicurio-start`).

When you have made your changes, then do click **Actions** > **Download Design**,
and copy the downloaded file as `api/public.openapi.yaml`.

Now from the base of the repository now update code generated by `make generate-api`.

Finally, edit your source code to adapt to the changes (if necessary)
and update your unit tests to cover new code and update to the changes.

## Contributing

See [CONTRIBUTING.md](docs/CONTRIBUTING.md) guide.

## Aknowledgements

This bootstrap repository is the result of the experience through
content-sources and idmsvc, so thanks to all the mates I have been
the opportunity to meet during that experience.

Big thanks to everybody, and I hope it could 

## References

Tech stack:

- Echo Framework: https://echo.labstack.com
- Logs:
  - https://pkg.go.dev/golang.org/x/exp/slog
- Database: https://gorm.io/docs/index.html
- Kafka Client Library: https://github.com/confluentinc/confluent-kafka-go
- Testing:
  - Testify: https://pkg.go.dev/github.com/stretchr/testify
  - Mockery: https://github.com/vektra/mockery
  - SqlMock: https://github.com/DATA-DOG/go-sqlmock
- Generators:
  - oapi-generator: https://github.com/deepmap/oapi-codegen   (Generate boilerplate for openapi)
  - go-jsonschema: https://git.sr.ht/~emersion/go-jsonschema  (Generate types for event schemas)
  - mockery: https://github.com/vektra/mockery                (Generate mocks from golang interfaces)

## Tools

Http clients
- https://httpie.io/docs/cli
- https://github.com/AnWeber/httpyac

Validate API
- https://quobix.com/vacuum/ (actually integrated in `make lint`)


[apicurio_site]: https://www.apicur.io/apicurito/
[apicurio_github]: https://www.apicur.io/apicurito/
[apicurio_images]: https://hub.docker.com/search?q=apicurio%2Fapicurito&type=image

